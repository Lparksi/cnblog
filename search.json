[{"title":"并查集","url":"/2025/Union_Found/","content":"Union Found aka DSU.用于解决动态连通性问题。最差时间复杂度(UF 4)N + M lg* N 近线性阶，效率很高。\n构造UF uf(size);复杂度 O(n)\n方法\n\n\n名称\n参数\n返回值类型\n作用\n\n\n\nconnected\nint p,q\nbool\n检查是否连接\n\n\nUFunion\nint p,q\nvoid\n将两个节点连接\n\n\n此处不使用 union 是为了避免与 stdc++.h 发生冲突。\n\n\n\n\n\n原理首先初始化一个大小为 n 的 id数组 表示最多有n种可能，即每个节点都是独立的。如果要联通两个节点，就把这两个节点的 id  更新为一样的（例如要把 a 和 b 联通，就需要把所有 id 为 b 的节点都更新为 a）\n优化方法Lazy approach 懒处理在合并时执行较少的操作，在查询时解读\n相对于 Version1 把 id 视为森林。Union p,q 使 p 成为 q 的子节点\nWeight 加权（避免树劣化）观察得到，树的高度越高，时间复杂度越劣，因此避免得到更高的树。当两个树合并时，永远将大的树放在前面，小的树放在后面。\npath compression 路径压缩将树扁平化，这会减少 root 函数回溯的次数，较少时间复杂度只需要改动 root 函数，使其在找寻根节点的过程中将该子树直接移到上一层节点上。经过加权和路径压缩优化后，UF的时间复杂度可以达到&#x3D;&#x3D;近线性&#x3D;&#x3D;。\n    int root(int i) &#123;          while (i != id[i]) &#123;              id[i] = id[id[i]];              i = id[i];          &#125;          return i;      &#125;\n实现Version 1\nclass UF &#123;    private:      vector&lt;int&gt; id;    public:      UF(int n) &#123;          id.resize(n);          for (int i = 0; i &lt; n; i++) id[i] = i;      &#125;      bool connected(int p, int q) &#123;          return id[p] == id[q];      &#125;      void UFunion(int p, int q) &#123;          int pid = id[p];          int qid = id[q];          for (int i = 0; i &lt; id.size(); i++) &#123;              if (id[i] == pid) id[i] = qid;          &#125;      &#125;  &#125;;\nVersion 2 Lazy approach 优化\nclass UF &#123;    private:      vector&lt;int&gt; id;      int root(int i) &#123;          while (i != id[i]) i = id[i];          return i;      &#125;    public:      UF(int n) &#123;          id.resize(n);          for (int i = 0; i &lt; n; i++) id[i] = i;      &#125;      bool connected(int p, int q) &#123;          return root(p) == root(q);      &#125;      void UFunion(int p, int q) &#123;          int i = root(p);          int j = root(q);          id[i] = j;      &#125;  &#125;;\nVersion 3 Weight 优化\nclass UF &#123;    private:      vector&lt;int&gt; id;      vector&lt;int&gt; sz;      int root(int i) &#123;          while (i != id[i]) i = id[i];          return i;      &#125;    public:      UF(int n) &#123;          id.resize(n);          sz.resize(n);          for (int i = 0; i &lt; n; i++) id[i] = i, sz[i] = 1;      &#125;      bool connected(int p, int q) &#123;          return root(p) == root(q);      &#125;      void UFunion(int p, int q) &#123;          int i = root(p);          int j = root(q);          if (i == j) return;          if (sz[i] &lt; sz[j]) &#123;              id[i] = j;              sz[j] += sz[i];          &#125; else &#123;              id[j] = i;              sz[i] += sz[j];          &#125;      &#125;  &#125;;\nVersion 4 path compression 路径压缩优化\nclass UF &#123;    private:      vector&lt;int&gt; id;      vector&lt;int&gt; sz;      int root(int i) &#123;          while (i != id[i]) &#123;              id[i] = id[id[i]];              i = id[i];          &#125;          return i;      &#125;    public:      UF(int n) &#123;          id.resize(n);          sz.resize(n);          for (int i = 0; i &lt; n; i++) id[i] = i, sz[i] = 1;      &#125;      bool connected(int p, int q) &#123;          return root(p) == root(q);      &#125;      void UFunion(int p, int q) &#123;          int i = root(p);          int j = root(q);          if (i == j) return;          if (sz[i] &lt; sz[j]) &#123;              id[i] = j;              sz[j] += sz[i];          &#125; else &#123;              id[j] = i;              sz[i] += sz[j];          &#125;      &#125;  &#125;;\n\n应用\n动态联通性问题\nKruskal 最小路问题\n\nPercolation 渗流在图中，存在一条贯穿上下的白色路径即认为该图是渗流的左侧是渗流的，右侧不是。此处白色方块有概率 p 是打开的。存在一个 p 使得渗流的可能性发生突变。\n可以通过新增一个虚拟上根和一个虚拟下根，每次只需要检查这两个虚拟根是否连接就能判断是否渗流\n实际应用\n电力\n水流\n社交网络\n\n","categories":["算法"],"tags":["并查集"]},{"title":"如何入门程序设计竞赛","url":"/2025/intro_to_xcpc/","content":"准备首先要端正态度，除了少部分天赋异鼎的天才以外，大部分选手都需要巨量的练习，这意味着你需要牺牲自己的一部分娱乐和休息时间进行高强度的训练。平时训练时也不能过度依赖AI，赛时是肯定不给你用AI的。软件方面，建议使用 Devc++ 5.11，大部分赛站都会提供这个软件，能够满足你基本的编译运行需求。\n知识平台\nOI-Wiki 程序设计竞赛的百科全书，在上面有大量的算法和解析\nHello 算法 绘图精美，详细解析几个基础的数据结构和算法，对入门有帮助\ncppreference 查询 C&#x2F;C++ 函数的具体定义和实现，算竟只用到其中很小一部分\n\n刷题平台\n洛谷 中国最大的刷题网站，有完善的知识点分类和难度分类，题解丰富，适合刷知识点\n牛客 经常举办高质量比赛，每周都有牛客周赛，适合新手参与，难度相对较低，结束后在 B站有视频讲解\nCodeforces 世界最大的刷题网站，主要锻炼思维，比赛时间一般在晚上10点半-12点半，纯英文题目，有文字解析\nAtcoder Atcoder的ABC(AtCoder Beginner Contest) 经常会出经典题，时间在晚上8点-9点40，纯英文题目，有文字解析\nVjudgeVjudge并不是刷题平台，但它能抓取其他平台的题目并免费翻译，里面也有一些高质量题单\n\n书籍\n洛谷的 深入浅程序设计竞赛（基础篇&#x2F;进阶篇），经典例题，可配合题单 https://vjudge.net/article/4196 使用\n俞勇的 算法竞赛\n挑战程序设计竞赛没有必要非要卖一本书，网络上也有很多高质量资源。\n\n怎么学常用算法&#x2F;数据结构：队列，栈，二叉堆（优先队列），哈希表，排序，简单贪心思想，前缀和，差分，字符串，图论基础，并查集，bfs，dfs，最短路，dijkstra堆优化，快速幂，位运算，倍增，简单构造算法，st表，三分，高精度，单调栈，单调队列，树状数组，线段树。\n学C++的STL这里注意到一个问题，像栈这样的数据结构，它的功能是确定的，如果使用C语言每次都要自己实现，但C++提供了STL库，其中包含了很多基础数据结构，能够直接拿来用。OI-Wiki介绍，但不要有心理负担，C是C++的子集，所有C语言的代码在C++依然成立，但C++提供了更多方便的扩展功能，文章的结尾会给出一个C++标准模板。\n高频基础考点队列，栈，二叉堆（优先队列），哈希表，排序，简单贪心思想，前缀和，差分，字符串，图论基础，并查集，bfs，dfs，最短路，dijkstra堆优化，快速幂，高精度这些都算是比较高频的考点，要先学会这些知识点，一般的流程是在 OI-Wiki 上学这个知识点的理论和实现然后到洛谷去刷这个知识点的题目（从简单开始刷），不会做的看题解。\n尽早开始刷题不要觉得自己什么都不会就不去参加比赛，建议新手至少每周都要参与牛客周赛和ABC，这两类比赛都是着重考察基础知识点的，随着练习量的提高，进步也会很明显。随后就要积极参与CF的比赛。\n各平台怎么用首先建议大家使用系统自带的 Edge 浏览器\nCodeforces官网：Codeforces\n比赛\n\n\n名称\n难度\n\n\n\n\nCodeforces Round Div 1,2,3,4\n数字越大越简单\n新手简易先刷DIv4和3\n\n\nEducational Codeforces Round\n一般对标Div2，但稍微简单，会出典题\n建议做\n\n\n插件CF betterCF是英文网站，CF better可以提供界面和内容的汉化首先安装 篡改猴，这是用户脚本的管理器使用 Edge 浏览器打开 篡改猴 - Microsoft Edge Addons 点击右侧的获取安装之后还需要打开 开发人员模式才能使脚本生效找到扩展-管理扩展或在地址栏输入 edge://extensions/ 打开开发人员模式点击此链接安装脚本 ：https://greasyfork.org/zh-CN/scripts/465777-codeforces-better如果打不开可以使用  https://ghfast.top/https://github.com/beijixiaohu/OJBetter/raw/main/script/release/codeforces-better.user.js再次进入Codeforces即可显示CF better页面\n\n功能在右上角进行登录和注册，比赛中有CF未来和过去的比赛，训练营有往年XCPC真题\n随便进入一场比赛，点击题目即可查看题目，提交代码时选择的编译器一般为G++，右下角的小框就是翻译工具，点击即可翻译那个方格的内容，当然更推荐点击题目里的Vjudge跳转，Vjudge的翻译一般更好（当然以原文为准，Vjudge也能可能出错），点击榜单可以查看当期榜单。\nAtcoder官网：https://atcoder.jp/和CF一样，Atcoder也有翻译插件https://greasyfork.org/zh-CN/scripts/471106-atcoder-betterhttps://ghfast.top/https://github.com/beijixiaohu/OJBetter/raw/main/script/release/atcoder-better.user.js首页会显示即将进行的比赛，和CF不同的是，Atcoder如果报名没做的话也是会扣分的。剩下的和CF差不多\n牛客官网：牛客竞赛OJ_ACM&#x2F;NOI&#x2F;CSP&#x2F;CCPC&#x2F;ICPC_信息学编程算法训练平台先做牛客周赛、小白月赛和各高校的校赛（群里一般都会转发）中文题面没啥好说的，官方比赛结束后会在B站上传视频解析\n洛谷官网：https://www.luogu.com.cn/点击左侧题库可以筛选知识点和难度进行刷题题目题解非常丰富\nVjudge官网：https://vjudge.net/一般使用插件跳转过来，需要登录才能查看翻译，选择左侧的Deepseek_zh或者Chatgpt-zh查看翻译。\n一般题目结构// 引入标准头文件，包含大部分常用 STL 容器和算法  #include &lt;bits/stdc++.h&gt;    // 定义 endl 为换行符，通常用于输出后刷新缓冲区，原理是 \\n 比 endl快，但在交互题中注意刷新缓冲区  #define endl &#x27;\\n&#x27;    // 使用类型别名，将 long long 类型定义为 ll，便于书写大整数类型  typedef long long ll;    // 使用标准命名空间 std，避免每次调用标准库函数时都要加 std::  using namespace std;      // solve 函数是解决问题的核心逻辑所在  // 用于像CF这样一个测试点有多组数据的情况  void solve() &#123;      &#125;    // 主函数 main 是程序的入口点  signed main() &#123;      // 提高输入输出效率：关闭 C 和 C++ 标准流的同步      // 这样可以加快程序运行速度，尤其在处理大量输入输出时      ios::sync_with_stdio(0);          // 解除 cin 和 cout 的绑定，进一步提升输入效率      cin.tie(0);          // 设置测试用例数量 T，默认为 1      int T = 1;          // 如果需要多组测试用例，可以取消下面这一行的注释，从输入读取 T 的值      // cin &gt;&gt; T;          // 循环执行 T 次 solve 函数      while (T--) &#123;          solve();      &#125;          // 程序正常结束，返回 0 表示成功退出      return 0;  &#125;","categories":["教程"],"tags":["入门","蓝桥杯","天梯赛","XCPC","百度之星"]},{"title":"在校大学生如何获取 Jetbrains 免费教育授权","url":"/2025/get_free_edu_jetbrains/","content":"背景Jetbrains 是著名的IDE开发公司，旗下有IDEA、pycharm等广受好评的IDE，作为大学生可以免费申请其教育授权。\n方式前往 申请页面 ，通过人机验证后，使用 大学电子邮件地址 方式验证身份。随后在校期间均可免费获取其授权，只需要在每年点击邮箱内的续费链接即可。\n学校域名不被认可？Jetbrains 的域名验证存放于JetBrains&#x2F;swot仓库，可以像该仓库提交 PR 来让自己的学校被许可。\n域名以 txt 格式逆序存放于 lib&#x2F;domains 文件夹内例如，我校学生域名 stu.aynu.edu.cn 即需要在 &#x2F;lib&#x2F;domains&#x2F;cn&#x2F;edu&#x2F;aynu&#x2F; 路径下创建一个名为 stu.txt 的文件，文件内写上学校的官方名称（中英文均可）可以参考 PR： https://github.com/JetBrains/swot/pull/26610\n","categories":["正版软件"],"tags":["Jetbrains"]},{"title":"如何使用 Docker Compose 让你的项目快速部署","url":"/2025/intro_to_docker_compose/","content":"WhyDocker 是一种容器化技术，可以将程序打包进容器，使其在不同主机上运行的效果相同（类似于虚拟机），将程序及其环境使用 Docker Compose 编排起来，可以实现快速敏捷上线。\nHow那么如何实现呢？首先要将程序本身打包为 Docker 镜像，具体的方法是使用 DockerFile\n这是一个典型的 Go语言两阶段部署方案，首先将go二进制文件编译出来，然后将其拷贝至极简的  apline 内核运行，同时暴露9000端口为业务端口\ntips： 如果你的业务涉及时区，就需要RUN apk add --no-cache tzdata ，golang:1.24-alpine是没有这个时区包的。\nFROM golang:1.24-alpine AS builder  WORKDIR /app  COPY go.mod go.sum ./  RUN go mod download  COPY . .      RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o server ./cmd/server  FROM alpine:latest  RUN apk add --no-cache tzdata  ENV TZ=Asia/Shanghai  RUN ln -sf /usr/share/zoneinfo/$TZ /etc/localtime    LABEL maintainer=&quot;i@parksi.top&quot;  LABEL description=&quot;bacend of project-ay&quot;  LABEL version=&quot;dev&quot;  LABEL name=&quot;project-ay&quot;    ENV GIN_MODE=release  ENV APP_SERVER_HOST=0.0.0.0  COPY --from=builder /app/server .  COPY --from=builder /app/config ./config    EXPOSE 9000    CMD [&quot;./server&quot;]\n\n程序本身的容器搞定了，那数据库呢？这个项目使用了 postgres + gis扩展 和 redis 为数据库，gis扩展的安装就已经很麻烦了，redis 更是在 Windows 下没有支持，那么使用 Docker 镜像来运行是一种方法。\n下面来看 compose\nname: ay-backend  services:    postgres:      image: postgis/postgis:17-3.5-alpine      restart: always      environment:        POSTGRES_USER: postgres        POSTGRES_PASSWORD: postgres        POSTGRES_DB: postgres      healthcheck:        test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -U postgres&quot;]        interval: 5s        timeout: 5s        retries: 5      volumes:        - pgdata:/var/lib/postgresql/data  #    ports:  #      - &quot;5433:5432&quot;    redis:      image: redis:bookworm      restart: always      healthcheck:        test: [&quot;CMD-SHELL&quot;, &quot;redis-cli ping&quot;]        interval: 5s        timeout: 5s        retries: 5      volumes:        - redisdata:/data      ports:        - &quot;6379:6379&quot;      app:      image: ay-backend:latest      build:        context: ..        dockerfile: scripts/Dockerfile      ports:        - &quot;9001:9000&quot;      logging:        driver: json-file        options:          max-size: 10m      environment:        - APP_POSTGRES_HOST=postgres        - APP_POSTGRES_PORT=5432        - APP_POSTGRES_USER=postgres        - APP_POSTGRES_PASSWORD=postgres        - APP_POSTGRES_DATABASE=postgres        - APP_REDIS_HOST=redis        - GIN_MODE=debug      depends_on:        postgres:          condition: service_healthy        redis:          condition: service_healthy      healthcheck:        test: [ &quot;CMD&quot;, &quot;wget&quot;, &quot;--quiet&quot;, &quot;--tries=1&quot;, &quot;--spider&quot;, &quot;http://localhost:9000/api/v1/health&quot; ]        interval: 30s        timeout: 10s        retries: 3        start_period: 40s  volumes:      pgdata:      redisdata:\n\n可以看出，不需要像往常一样下载postgres，gis扩展，redis…安装，Docker管理了这一切，你只需要指定一个靠谱的Docker镜像，配置参数，让后启动即可！这就是Docker的魅力。需要注意的是：\n\nDocker默认并不会映射数据库的数据文件，也就是说，你不手动映射的话，每次启动你都会获得一个全新的数据库，推荐做法是使用 volume 进行存储。\n在生产环境中，数据库端口没有必要开放，除了对外服务的9001:9000是必要的外，数据库的6379、5432 都不是必要的，是同一个编排内，Docker compose会自动创建一个网络，他们使用容器名为host进行通信，举个例子，容器内要访问redis只要使用redis:6379即可，不需要暴露至主机。\n这三个容器是有依赖关系的，主程序必须等到两个数据库初始化完成才能启动，此处使用 depends_on 和 healthcheck 完成这一点\n\n","categories":["Docker"],"tags":["Docker"]}]